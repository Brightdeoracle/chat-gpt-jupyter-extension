// The code in this file will be injected by creating an element on the page
// and injecting a script element onto the page so that I can access the
// existing Jupyter page code.

(function () {

	// Function that parses a chat cell and returns a dict that contains
	// the parsed contents of the cell. The dict will contain the following
	// keys:
	// - cell_type: The type of cell, either "markdown" or "code"
	// - thread: The thread identifier, if any
	// - language: The programming language identifier, if any
	// - chain: Whether to chain with previous cells in thread (default False)
	// - prompt: The name of the prompt to use (currently prepend) when 
	// - text: The text of the cell stripped of the header and switches

	// The general structure of a markdown cell that we treat specially is:
	// Header
	// One or more switches
	// Text
	
	// A cell contains a header that is on the first line of the cell
	// The header always begins with `#####`
	// It is followed by one of chat, prompt, or response
	// If it is chat or prompt, it may be followed by a colon and an identifier
	// If it is response it cannot have an identifier

	// Currently only chat cells support switches
	// Where /switch is /nochain and /prompt:name
	// /nochain is used to stop chaining
	// /prompt is used to identify the prompt template to use for this cell

	// I'm not really happy about this asymmetry but let's go with it for now
	const parseHeader = /^\s*\#\#\#\#\#\s*(chat|prompt|response):?\s*(.*)$/;
	const parseSwitch = /^\s*\/(nochain|prompt):?\s*(.*)$/;

	const parseCell = function(cell) {
		let result = {}
		let lines = cell.get_text().split(/\r?\n/);
		
		let contents = []
		if (lines.length < 1) {
			result.cell_type = "unknown";
			return result;
		} else {
			lines.forEach((line) => {
				const matches = line.match(parseHeader);
				if (matches) {
					const [, key, value] = matches;
					if (key === "chat") {
						result.cell_type = "chat";
						result.thread = value.trim();
					} else if (key === "prompt") {
						result.cell_type = "prompt";
						result.prompt = value.trim();
					} else if (key === "response") {
						result.cell_type = "response";
					}
				} else {
					const switchMatches = line.match(parseSwitch);
					if (switchMatches) {
						const [, key, value] = switchMatches;
						if (key === "nochain") {
							result.chain = false;
						} else if (key === "prompt") {
							result.prompt = value.trim();
						}
					} else {
						contents.push(line);
					}
				}
			});
		}
		const body = contents.join("\n");
		result.text = body;

		if (result.cell_type === "chat") {
			if (result.chain === undefined) {
				result.chain = true; // default if not specified
			}
			if (result.prompt === undefined) {
				result.prompt = ""; // default if not specified
			}
		}
		if (result.cell_type === undefined) {
			result.cell_type = "unknown"; // default if not specified
		}
		return result;
	}

	// Dictionary that maps programming language to a markdown language string
	// Note that the keyword is always in lowercase.
	const keywordToProgrammingLanguage = {
		"python": "python",
		"java": "java",
		"c#": "csharp",
		"c sharp": "csharp",
		"javascript": "javascript",
		"f#": "fsharp",
		"php": "php",
		"r": "r",
	};

	// Create a regular expression that matches any of the words in the
	// dictionary. We use the "|" character to match any of the words,
	// surrounded by "\b" (word boundary) characters to ensure that we
	// only match whole words.
	const detector = new RegExp(`\\b(${Object.keys(keywordToProgrammingLanguage).join("|")})\\b`, "g");

	// Detect the most likely programming language by counting the frequency
	// of programming language keywords in the text. Returns the identifier.
	// This was all generated by ChatGPT!
	const detectProgrammingLanguage = function (text) {
		// Use the regex to find all matches in the string. The "match" method
		// will return an array of matches, or null if there are no matches.
		const matches = text.toLowerCase().match(detector);
		// Initialize the result object with counts of 0 for each identifier.
		const result = Object.values(keywordToProgrammingLanguage).reduce((acc, id) => {
			acc[id] = 0;
			return acc;
		}, {});
		// If there were any matches, update the counts in the result object.
		if (matches) {
			matches.forEach((word) => {
				const id = keywordToProgrammingLanguage[word];
				result[id]++;
			});
		}

		// Use Object.entries to get an array of key-value pairs.
		const entries = Object.entries(result);
		// Sort the entries in descending order by the value.
		const sorted = entries.sort((a, b) => b[1] - a[1]);
		// Use Array.find to find the first entry with the highest count.
		const [key, count] = sorted.find(([key, count]) => count === sorted[0][1]);
		// Return the key with the highest count if count > 0
		if (count === 0) {
			return "";
		}
		return key;
	}

	// Function that will search backwards through all cells and return a
	// string that contains all the previous queries and responses for the
	// specified thread. It ignores the raw_response cells preferring to 
	// return the contents of code cells from previous responses as well.
	const buildQueryContext = function (thread) {
		let result = "";
		const cells = Jupyter.notebook.get_cells();
		const currentCellIndex = Jupyter.notebook.get_selected_index();
		for (let i = currentCellIndex - 1; i >= 0; i--) {
			let cell = cells[i];
			if (cell.metadata.chatgpt_thread === thread) {
				if (cell.metadata.chatgpt_cell !== "raw_response") {
					const parsedCell = parseCell(cell);

					// If code cell, add code block markdown
					if (cell.metadata.chatgpt_cell === "code") {
						result = "```\n" + parseCell.text + "\n```\n" + result;
					} else {
						// If a prompt cell then add the full prompt
						const prompt = getPrompt(parsedCell);
						result = prompt + "\n" + result;
					}
				}
			}
		}
		return result;
	}

	var prompts = {};

	const dumpParsedCell = function(parsedCell) {
		console.log("cell_type", parsedCell.cell_type);
		console.log("thread", parsedCell.thread);
		console.log("prompt", parsedCell.prompt);
		console.log("nochain", parsedCell.nochain);
		console.log("text", parsedCell.text);
	}

	const getPrompt = function (parsedCell) {
		let prompt = parsedCell.text;
		if (parsedCell.prompt !== "") {
			prompt = prompts[parsedCell.prompt] + prompt;
		}
		return prompt;
	}

	// Jupyter custom action that will send the query in the current cell
	// to ChatGPT along with the query context.
	const sendToChatGPT = function () {
		let cell = Jupyter.notebook.get_selected_cell();

		const parsedCell = parseCell(cell);
		// dumpParsedCell(parsedCell);

		if (parsedCell.cell_type === "chat") {
			cell.metadata.chatgpt_cell = "query";
			cell.metadata.chatgpt_thread = parsedCell.thread;
			cell.metadata.chatgpt_language = parsedCell.language;

			const prompt = getPrompt(parsedCell);
			let context = "";
			if (parsedCell.chain) {
				context = buildQueryContext(parsedCell.thread);
			}

			let query = context + "\n" + prompt;
			let language = detectProgrammingLanguage(query);
			window.postMessage({
				type: "QUERY_CHATGPT",
				query: query,
				language: language,
				thread: parsedCell.thread
			}, "*");

			cell.render();
		} else if (parsedCell.cell_type === "prompt") {
			// Add this prompt to the dictionary of prompts
			prompts[parsedCell.prompt] = parsedCell.text;
			cell.render();
		} else {
			// Perform the default SHIFT+ENTER behavior which is execute
			// current code cell and move to next cell.
			cell.execute();
			Jupyter.notebook.select_next();
		}

		// Don't run default action
		return false;
	}

	// Insert above and below
	const insertChatCell = function (above) {
		if (above) {
			Jupyter.notebook.insert_cell_above();
			Jupyter.notebook.select_prev();
		} else {
			Jupyter.notebook.insert_cell_below();
			Jupyter.notebook.select_next();
		}
		Jupyter.notebook.cells_to_markdown();
		Jupyter.notebook.get_selected_cell().set_text("##### chat\n");
		Jupyter.notebook.get_selected_cell().focus_editor();
	}

	// Jupyter custom action to insert a new ChatGPT cell above the current
	const newChatCellAbove = function () {
		insertChatCell(true);
		return false;
	}

	// Jupyter custom action to insert a new ChatGPT cell below the current
	const newChatCellBelow = function () {
		insertChatCell(false);
		return false;
	}

	// This function takes a response from ChatGPT which will contain markdown
	// code blocks. It will do two things: 1/ return a list of all the code
	// blocks and 2/ annotate the code blocks with the passed in programming
	// language.
	//
	// There is a special case in this function where there are no code blocks
	// detected in the response AND the language is NOT unknown. In that case
	// we will surround the entire annotatedResponse with a default code block
	// annotated iwth the language. I have seen ChatGPT return such "naked
	// code" responses and this is needed to handle this case.
	const extractCodeBlocks = function (language, response) {
		// Do nothing if language is unknown
		if (language === "") {
			return [response, []];
		}

		let lines = response.split("\n");
		let inCodeBlock = false;
		let annotatedResponse = [];
		let currentBlock = [];
		let codeBlocks = [];

		// iterate over the lines and look for markdown code blocks
		for (const line of lines) {
			if (line !== "") {
				if (line.startsWith("```")) {
					inCodeBlock = !inCodeBlock;
					if (inCodeBlock) {
						// annotate the code block with the language
						annotatedResponse.push("```" + language);
					} else {
						// termainate the code block
						annotatedResponse.push("```");
						// add the current block to the list of code blocks
						codeBlocks.push(currentBlock.join("\n"));
						currentBlock = [];
					}
				} else {
					if (inCodeBlock) {
						// add the current line to the current block and the
						// annotated response
						currentBlock.push(line);
					}
					annotatedResponse.push(line);
				}
			}
		}

		if (codeBlocks.length === 0 && language !== "") {
			const code = annotatedResponse.join("\n");
			currentBlock.push(`\`\`\`${language}`)
			currentBlock.push(code);
			currentBlock.push("```");
			codeBlocks.push(code)
			return [currentBlock.join("\n"), codeBlocks];
		}
		else {
			return [annotatedResponse.join("\n"), codeBlocks];
		}
	}

	// Generated by ChatGPT in Jupyter :)
	const formatDate = function () {
		var now = new Date();
		var date = [now.getMonth() + 1, now.getDate(), now.getFullYear()];
		var time = [now.getHours(), now.getMinutes(), now.getSeconds()];
		var suffix = (time[0] < 12) ? "AM" : "PM";
		time[0] = (time[0] < 12) ? time[0] : time[0] - 12;
		time[0] = time[0] || 12;

		// If seconds and minutes are less than 10, add a zero
		for (var i = 1; i < 3; i++) {
			if (time[i] < 10) {
				time[i] = "0" + time[i];
			}
		}

		return date.join("/") + " " + time.join(":") + " " + suffix;
	}

	// Listen for post messages coming from the content script
	// There is a BEGIN message that signfies the start of a response
	// There is a stream of STREAM messages that contain the incremental response
	// There is an END message that signifies the end of the response
	const waiting_msg = "##### response: waiting for ChatGPT to respond...";

	var start_time = new Date();
	var currentStreamingCell = null;

	// Register event handler to receive messages from the content script
	// which acts as a broker for messages coming from the background script
	// and ultimately ChatGPT.
	window.addEventListener("message", function (event) {
		if (event.data.type && (event.data.type === "BEGIN_CONTENT_SCRIPT")) {

			// Create a new markdown cell below the query to store the
			// result that is streamed back from ChatGPT.
			Jupyter.notebook.insert_cell_below();
			Jupyter.notebook.select_next();
			Jupyter.notebook.cells_to_markdown();

			// Start timer for request - this will include time spent in 
			// the ChatGPT queue
			start_time = new Date();

			// Insert a message into the cell to say we're starting now.
			currentStreamingCell = Jupyter.notebook.get_selected_cell();
			currentStreamingCell.set_text(waiting_msg);

		} else if (event.data.type && (event.data.type === "STREAM_CONTENT_SCRIPT")) {

			// This gets called when there is new content from ChatGPT. 
			// All the previous content is replaced with the new content.
			var response = event.data.text;
			var current_time = new Date();
			var time_difference = current_time - start_time;
			var seconds = Math.floor(time_difference / 1000);

			// Prepend the ChatGPT response with the time elapsed
			var msg = `##### response: ${seconds} seconds elapsed\n\n${response}`;
			currentStreamingCell.set_text(msg);

		} else if (event.data.type && (event.data.type === "END_CONTENT_SCRIPT")) {
			// The callback message has detected programming language 
			let language = event.data.language;
			let thread = event.data.thread;

			// Get the complete response from ChatGPT from the streaming cell
			let text = currentStreamingCell.get_text();
			text = text.replace(/^\#\#\#\#\# response.*\n/, "");

			// Use the detected programming language in the query to annotate
			// the markdown code blocks to ensure we syntax highlight
			// correctly.
			const [annotatedResponse, codeBlocks] = extractCodeBlocks(language, text);

			// Replace the elapsed time message with a timestamp message that
			// tells the user when the response was generated, how long
			// it took to generate, and what thread the response was for
			const elapsed_time = Math.floor((new Date() - start_time) / 1000);
			if (thread !== "") {
				thread = `in thread ${thread}`
			}
			var summary = `##### response generated ${thread} by ChatGPT in ${elapsed_time} seconds at ${formatDate(start_time)}\n`;
			currentStreamingCell.select();
			currentStreamingCell.set_text(summary + annotatedResponse);
			currentStreamingCell.render();

			const index = Jupyter.notebook.find_cell_index(currentStreamingCell);
			Jupyter.notebook.select(index);

			// Now inject the parsed code blocks into the notebook after
			// currentStreamingCell
			for (var i = 0; i < codeBlocks.length; i++) {
				Jupyter.notebook.insert_cell_below();
				Jupyter.notebook.select_next();
				let cell = Jupyter.notebook.get_selected_cell();
				cell.metadata.chatgpt_cell = "code";
				cell.metadata.chatgpt_language = language;
				cell.metadata.chatgpt_thread = thread;
				cell.set_text(codeBlocks[i]);
			}
		} else if (event.data.type && (event.data.type === "ERROR_LOGIN_CONTENT_SCRIPT")) {
			currentStreamingCell.set_text("Please login to [ChatGPT first](https://chat.openai.com)")
			currentStreamingCell.render();
		}
	});

	// Register commands with Jupyter. There will be two commands:
	// 1. sendToChatGPT: this, when invoked in a Markdown cell will send
	//   the contents of the cell to ChatGPT only if the cell is marked
	// 	 as a chat cell.
	// 2. newChatCell: this, when invoked in command mode, will insert a new
	//   markdown cell and mark it as a chat cell.
	const keyboard_manager = Jupyter.notebook.keyboard_manager;
	const sendToChatGptAction = {
		icon: 'fa-comments',
		help: 'Send to ChatGPT',
		handler: sendToChatGPT
	};
	const sendToChatGptActionName = keyboard_manager.actions.register(
		sendToChatGptAction,
		'send-to-chatgpt',
		'auto');

	const newChatCellAboveAction = {
		icon: 'fa-level-up',
		help: 'New ChatGPT Cell Above',
		handler: newChatCellAbove
	};
	const newChatCellBelowAction = {
		icon: 'fa-level-down',
		help: 'New ChatGPT Cell Below',
		handler: newChatCellBelow
	};
	const newChatCellAboveActionName = keyboard_manager.actions.register(
		newChatCellAboveAction,
		'new-chatgpt-cell-above',
		'auto');
	const newChatCellBelowActionName = keyboard_manager.actions.register(
		newChatCellBelowAction,
		'new-chatgpt-cell-below',
		'auto');

	keyboard_manager.edit_shortcuts.add_shortcut('shift-enter',
		sendToChatGptActionName);
	keyboard_manager.command_shortcuts.add_shortcut('shift-c',
		newChatCellAboveActionName);
	keyboard_manager.command_shortcuts.add_shortcut('c',
		newChatCellBelowActionName);

	Jupyter.toolbar.add_buttons_group([
		sendToChatGptActionName,
		newChatCellAboveActionName,
		newChatCellBelowActionName]);

	// Log that we successfully initialized the extension
	console.log('Im in yr page, injecting scripts');
})();