// The code in this file will be injected by creating an element on the page
// and injecting a script element onto the page so that I can access the
// existing Jupyter page code.

// TODO: Empirically determine the limit of CHAT GPT input token length for
// the question. But for now let's just use a 6000 character limit.

// TODO: move this file from the background to the content-script dir

const CHAR_LIMIT = 6000;

(function() {

	// Strip blank lines and markdown from the first line of a cell that
	// identifies the cell as either a query or response cell.
	const stripChatMarkdown = function(cell) {
		let text = cell.get_text();
		let thread = "";
		const extractThreadId = /^\s*\#\#\#\#\#\s*chat:(.*)$/;
		if (cell.cell_type == 'markdown') {
			let lines = text.split("\n");
			let strippedLines = [];
			for (const line of lines) {
				if (!line.match(/^\s*\#\#\#\#\#\s*chat.*/) && 
					!line.match(/^\s*\#\#\#\#\#\s*response.*/)) {
						strippedLines.push(line);
				} 
				const matches = line.match(extractThreadId);
				if (matches) {
					const [, id] = matches;
					thread = id.trim();
				}
			}
			text = strippedLines.join("\n");
		}
		return [text, thread];
	}

	// Dictionary that maps programming language to a markdown language string
	// Note that the keyword is always in lowercase.
	const keywordToProgrammingLanguage = {
		"python": "python",
		"java": "java",
		"c#": "csharp",
		"c sharp": "csharp",
		"javascript": "javascript",
		"f#": "fsharp",
		"php": "php",
		"r": "r",
	};

	// Detect the most likely programming language by counting the frequency
	// of programming language keywords in the text. Returns the identifier.
	// This was all generated by ChatGPT!
	const detectProgrammingLanguage = function (text) {
		// Create a regular expression that matches any of the words in the
		// dictionary. We use the "|" character to match any of the words,
		// surrounded by "\b" (word boundary) characters to ensure that we
		// only match whole words.
		const regex = new RegExp(`\\b(${Object.keys(keywordToProgrammingLanguage).join("|")})\\b`, "g");
		// Use the regex to find all matches in the string. The "match" method
		// will return an array of matches, or null if there are no matches.
		const matches = text.match(regex);
		// Initialize the result object with counts of 0 for each identifier.
		const result = Object.values(keywordToProgrammingLanguage).reduce((acc, id) => {
			acc[id] = 0;
			return acc;
		}, {});
		// If there were any matches, update the counts in the result object.
		if (matches) {
			matches.forEach((word) => {
				const id = keywordToProgrammingLanguage[word];
				result[id]++;
			});
		}

		// Use Object.entries to get an array of key-value pairs.
		const entries = Object.entries(result);
		// Sort the entries in descending order by the value.
		const sorted = entries.sort((a, b) => b[1] - a[1]);
		// Use Array.find to find the first entry with the highest count.
		const [key, count] = sorted.find(([key, count]) => count === sorted[0][1]);
		// Return the key with the highest count.
		return key;
	}

	// TODO: empircally determine what the current ChatGPT experience
	// sends as context. I wonder if it sends everything?

	// Function that will search backwards through all cells and return a
	// string that contains all the previous queries and responses for the
	// specified thread. It ignores the raw_response cells preferring to 
	// return the contents of code cells from previous responses as well.
	// It also uses metadata to determine the programming language of the
	// query context so that users can omit the language identifier from
	// their most recent query(s).
	const buildQueryContext = function(thread, language) {
		let result = "";
		const cells = Jupyter.notebook.get_cells();
		const currentCellIndex = Jupyter.notebook.get_selected_index();
		for (let i = currentCellIndex - 1; i >= 0; i--) {
			let cell = cells[i];
			if (cell.metadata.chatgpt_thread === thread) {
				if (cell.metadata.chatgpt_cell !== "raw_response") {
					const [text, _] = stripChatMarkdown(cell);

					// If code cell, add code block markdown
					if (cell.metadata.chatgpt_cell === "code") {
						result = "```\n" + text + "\n```\n" + result;
					} else {
						result = text + "\n" + result;
					}
					
					if (language === "" && cell.metadata.chatgpt_language !== "") {
						language = cell.metadata.chatgpt_language;
					}
				}
			}
		}
		return [result, language];
	}

	// Function that analyzes the current query cell. It detects the 
	// programming language and marks the cell metadata as a query cell.
	// It also returns the query text, thread and language.
	const analyzeQueryCell = function(cell) {
		let [text, thread] = stripChatMarkdown(cell);
		let language = detectProgrammingLanguage(text);
		cell.metadata.chatgpt_cell = "query";
		cell.metadata.chatgpt_thread = thread;
		cell.metadata.chatgpt_language = language;

		return [text, thread, language];
	}

	// Jupyter custom action that will send the query in the current cell
	// to ChatGPT along with the query context.
	const sendToChatGPT = function() {
		let cell = Jupyter.notebook.get_selected_cell();
		const detectChat = /^\s*\#\#\#\#\#\s*chat/;

		if (cell.cell_type === "markdown") {
			if (detectChat.test(cell.get_text())) {
				const [query, thread, language] = analyzeQueryCell(cell);
				const [context, queryLanguage] = buildQueryContext(thread, language);

				window.postMessage({
					type: "QUERY_CHATGPT",
					query: context + "\n" + query,
					language: queryLanguage
				}, "*");
			}
			cell.render();
		} else if (cell.cell_type === "code") {
			// Perform the default SHIFT+ENTER behavior which is execute
			// current code cell and move to next cell.
			cell.execute();
			Jupyter.notebook.select_next();
		}
	}

	// // Register a custom action that will either execute the current cell or
	// // pop an alert (simulate send to GPT)
	// var send_to_chatgpt = function() {
	// 	var cell = Jupyter.notebook.get_selected_cell();
	// 	if (cell.cell_type == 'markdown') {
	// 		question = cell.get_text();
			
	// 		if (question.startsWith('##### chat')) {
	// 			// Use only the query in the current cell to detect the
	// 			// current programming language
	// 			current_programming_language = detect_programming_language(question);

	// 			// Get the context from all relevant previous cells and send
	// 			// that as the query to ChatGPT
	// 			query = removeLanguageAnnotations(get_previous_cells());
	// 			console.log(`Send to ChatGPT ${query}`);

	// 			// TODO: what does * mean and implications for the timeout?
	// 			window.postMessage({type: "QUERY_CHATGPT", text: query}, "*");
	// 		}
	// 		cell.render();
	// 	} else if (cell.cell_type == 'code') {
	// 		// Perform the default SHIFT+ENTER behavior which is execute
	// 		// current code cell and move to next cell.
	// 		cell.execute();
	// 		Jupyter.notebook.select_next();
	//  	} else {
	// 		// Not sure if this ever gets hit
	// 		console.log("No selected cell");
	// 	}
	// };
	// // TODO: need to have a way to include changes that the user may have
	// // manually added to the code.
	// var get_previous_cells = function() {
	// 	let cells = Jupyter.notebook.get_cells();
	// 	let result = "";
	// 	let current_cell = Jupyter.notebook.get_selected_index() + 1;
	// 	for (let i = current_cell; i >= 0; i--) {
	// 		let cell = cells[i];
	// 		if (cell.cell_type == 'markdown') {
	// 			let text = cell.get_text();
	// 			if (text.startsWith('##### chat')) {
	// 				text = text.replace(/^\s*\#\#\#\#\#\s*chat\s*/, "");
	// 				result = text + result;
	// 			} else if (text.startsWith("##### response")){
	// 				text = text.replace(/^\s*\#\#\#\#\#\s*response\s*/, "");
	// 				result = text + result;
	// 			} 			
	// 		}
	// 	}
	// 	return result;
	// }

	// // This function will try to detect the programming language of the
	// // string that is passed in. It will return a string that can be used
	// // by markdown to specify the language. This is a crappy heuristic that
	// // only returns the first match. It will return unknown if no match is 
	// // found.
	// var detect_programming_language = function(str) {
	// 	let str_lowercase = (str + " ").toLowerCase();
	// 	for (const [key, value] of Object.entries(keyword_to_programming_language)) {
	// 		if (str_lowercase.includes(" " + key + " ")) {
	// 			return value;
	// 		}
	// 	}
	// 	return "unknown";
	// }

	// This function takes a response from ChatGPT which will contain markdown
	// code blocks. It will do two things: 1/ return a list of all the code
	// blocks and 2/ annotate the code blocks with the passed in programming
	// language.
	//
	// There is a special case in this function where there are no code blocks
	// detected in the response AND the language is NOT unknown. In that case
	// we will surround the entire annotatedResponse with a default code block
	// annotated iwth the language. I have seen ChatGPT return such "naked
	// code" responses and this is needed to handle this case.
	const extractCodeBlocks = function(language, response) {
		// Do nothing if language is unknown
		if (language === "unknown") {
			return [response, []];
		}

		let lines = response.split("\n");
		let inCodeBlock = false;
		let annotatedResponse = [];
		let currentBlock = [];
		let codeBlocks = [];

		// iterate over the lines and look for markdown code blocks
		for (const line of lines) {
			if (line != "") {
				if (line.startsWith("```")) {
					inCodeBlock = !inCodeBlock;
					if (inCodeBlock) {
						// annotate the code block with the language
						annotatedResponse.push("```" + language);
					} else {
						// termainate the code block
						annotatedResponse.push("```");
						// add the current block to the list of code blocks
						codeBlocks.push(currentBlock.join("\n"));
						currentBlock = [];
					}
				} else {
					if (inCodeBlock) {
						// add the current line to the current block and the
						// annotated response
						currentBlock.push(line);
					}
					annotatedResponse.push(line);
				}
			}
		}

		if (codeBlocks.length == 0 && language != "unknown") {
			const code = annotatedResponse.join("\n");
			currentBlock.push(`\`\`\`${language}`)
			currentBlock.push(code);
			currentBlock.push("```");
			codeBlocks.push(code)
			return [currentBlock.join("\n"), codeBlocks];
		}
		else {
			return [annotatedResponse.join("\n"), codeBlocks];
		}
	}

	// It's odd that I need to strip out the language annotations from the
	// query. But if I don't then ChatGPT will sometimes change the language
	// based on my experiments to something random like python when I sent
	// it csharp code blocks.
	const removeLanguageAnnotations = function(query) {
		let lines = query.split("\n");
		let annotatedQuery = [];
		for (const line of lines) {
			if (line.startsWith("```")) {
				annotatedQuery.push("```");
			} else {
				annotatedQuery.push(line);
			}
		}
		return annotatedQuery.join("\n");
	}

	// var current_programming_language = "";

	// // Register a custom action that will either execute the current cell or
	// // pop an alert (simulate send to GPT)
	// var send_to_chatgpt = function() {
	// 	var cell = Jupyter.notebook.get_selected_cell();
	// 	if (cell.cell_type == 'markdown') {
	// 		question = cell.get_text();
			
	// 		if (question.startsWith('##### chat')) {
	// 			// Use only the query in the current cell to detect the
	// 			// current programming language
	// 			current_programming_language = detect_programming_language(question);

	// 			// Get the context from all relevant previous cells and send
	// 			// that as the query to ChatGPT
	// 			query = removeLanguageAnnotations(get_previous_cells());
	// 			console.log(`Send to ChatGPT ${query}`);

	// 			// TODO: what does * mean and implications for the timeout?
	// 			window.postMessage({type: "QUERY_CHATGPT", text: query}, "*");
	// 		}
	// 		cell.render();
	// 	} else if (cell.cell_type == 'code') {
	// 		// Perform the default SHIFT+ENTER behavior which is execute
	// 		// current code cell and move to next cell.
	// 		cell.execute();
	// 		Jupyter.notebook.select_next();
	//  	} else {
	// 		// Not sure if this ever gets hit
	// 		console.log("No selected cell");
	// 	}
	// };

	// Generated by ChatGPT in Jupyter :)
	var formatDate = function() {
		var now = new Date();
		var date = [now.getMonth() + 1, now.getDate(), now.getFullYear()];
		var time = [now.getHours(), now.getMinutes(), now.getSeconds()];
		var suffix = (time[0] < 12) ? "AM" : "PM";
		time[0] = (time[0] < 12) ? time[0] : time[0] - 12;
		time[0] = time[0] || 12;

		// If seconds and minutes are less than 10, add a zero
		for (var i = 1; i < 3; i++) {
			if (time[i] < 10) {
				time[i] = "0" + time[i];
			}
		}

		return date.join("/") + " " + time.join(":") + " " + suffix;
	}

	// Listen for post messages coming from the content script
	// There is a BEGIN message that signfies the start of a response
	// There is a stream of STREAM messages that contain the incremental response
	// There is an END message that signifies the end of the response
	const waiting_msg = "##### response: waiting for ChatGPT to respond...";

	var start_time = new Date();

	// Register event handler to receive messages from the content script
	// which acts as a broker for messages coming from the background script
	// and ultimately ChatGPT.
	window.addEventListener("message", function(event) {
		if (event.data.type && (event.data.type == "BEGIN_CONTENT_SCRIPT")) {

			// Create a new markdown cell below the query to store the
			// result that is streamed back from ChatGPT.
			Jupyter.notebook.insert_cell_below();
			Jupyter.notebook.select_next();
			Jupyter.notebook.cells_to_markdown();

			// Start timer for request - this will include time spent in 
			// the ChatGPT queue
			start_time = new Date();

			// Insert a message into the cell to say we're starting now.
			Jupyter.notebook.get_selected_cell().set_text(waiting_msg);

		} else if (event.data.type && (event.data.type == "STREAM_CONTENT_SCRIPT")) {

			// This gets called when there is new content from ChatGPT. 
			// All the previous content is replaced with the new content.
			var response = event.data.text;
			var current_time = new Date();
			var time_difference = current_time - start_time;
			var seconds = Math.floor(time_difference / 1000) % 60;

			// Prepend the ChatGPT response with the time elapsed
			var msg = `##### response: ${seconds} seconds elapsed\n\n${response}`;
			Jupyter.notebook.get_selected_cell().set_text(msg);

		} else if (event.data.type && (event.data.type == "END_CONTENT_SCRIPT")) {

			// Get the complete response from ChatGPT from the cell
			let cell = Jupyter.notebook.get_selected_cell();
			let text = cell.get_text();

			// The callback message has detected programming language 
			let language = event.data.language;
			console.log("from callback language: " + language);

			text = text.replace(/^\#\#\#\#\# response.*\n/, "");

			// Use the detected programming language in the query to annotate
			// the markdown code blocks to ensure we syntax highlight
			// correctly.
			const [annotatedResponse, codeBlocks] = extractCodeBlocks(language, text);

			// Replace the elapsed time message with a timestamp message that
			// tells the user when the response was generated.
			var summary = `##### response generated by ChatGPT at ${formatDate(start_time)}\n`;
			cell.set_text(summary + annotatedResponse);
			cell.render();

			// Now inject the parsed code blocks into the notebook after
			// the response markdown cell.
			for (var i = 0; i < codeBlocks.length; i++) {
				Jupyter.notebook.insert_cell_below();
				Jupyter.notebook.select_next();
				let cell = Jupyter.notebook.get_selected_cell();
				cell.metadata.chatgpt_cell = "code";
				cell.metadata.chatgpt_language = language;
				cell.metadata.chatgpt_thread = ""; // TODO
				cell.set_text(codeBlocks[i]);
			}
		}
	});

	// TODO: figure out what real values to use for these
	var action = {
		icon: 'fa-comment', 
		help: 'Send to ChatGPT',
		help_index: 'zz',
		// handler: send_to_chatgpt
		handler: sendToChatGPT
	};
	var prefix = 'auto';
	var action_name = 'send-to-chatgpt';
	var full_action_name = Jupyter.actions.register(action, action_name, prefix); 

	// TODO: I don't really care about whether someone has overridden the shortcut
	// in another extension. Feel free to fix this!
	Jupyter.notebook.keyboard_manager.edit_shortcuts.add_shortcut('shift-enter', full_action_name);

	// Log that we successfully initialized the extension
	console.log('Im in yr page, injecting scripts');
})();