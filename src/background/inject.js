// The code in this file will be injected by creating an element on the page
// and injecting a script element onto the page so that I can access the
// existing Jupyter page code.

// TODO: Empirically determine the limit of CHAT GPT input token length for
// the question. But for now let's just use a 6000 character limit.

const CHAR_LIMIT = 6000;

(function() {
	// Function that will search backwards through all cells and return a
	// string that contains the contents of all the concatenated cells that
	// start with ##### chat. This function will stop when it 

	// TODO: need to have a way to include changes that the user may have
	// manually added to the code.
	var get_previous_cells = function() {
		var cells = Jupyter.notebook.get_cells();
		var code = "";
		var current_cell = Jupyter.notebook.get_selected_index();
		for (var i = current_cell; i >= 0; i--) {
			var cell = cells[i];
			if (cell.cell_type == 'markdown') {
				var text = cell.get_text();
				if (text.startsWith('##### chat')) {
					text = text.replace(/^\s*\#\#\#\#\#\s*chat\s*/, "");
					code = text + code;
				} else if (text.startsWith("##### response")){
					text = text.replace(/^\s*\#\#\#\#\#\s*response\s*/, "");
					code = text + code;
				} 			}
		}
		return code;
	}

	// Generated by ChatGPT in Jupyter 
	var extractCodeBlocks = function(str) {
		// Use a regular expression to match the code block markers and
		// capture the code between them
		const regex = /^```\n([\s\S]*?)\n```$/gm;
		const matches = str.match(regex);

		if (!matches) return [];
		return matches.map((match) => match.replace(regex, '$1'));
	}

	// Register a custom action that will either execute the 
	// current cell or pop an alert (simulate send to GPT)
	var send_to_chatgpt = function() {
		var cell = Jupyter.notebook.get_selected_cell();
		if (cell.cell_type == 'markdown') {
			code = cell.get_text();
			if (code.startsWith('##### chat')) {
				code = get_previous_cells();
				// Strip off the %chat prefix
				// code = code.replace(/^\s*\#\#\#\#\#\s*chat\s*/, "");
				console.log(`Send to ChatGPT ${code}`);

				// Render the cell as markdown
				// TODO: something to say that it is working and then remove
				// the working when it is done?
				cell.render();

				// Must post a message to the content_script to send to ChatGPT
				// TODO: what does * mean and implications for the timeout?
				window.postMessage({type: "QUERY_CHATGPT", text: code}, "*");
			} else {
				cell.execute();
			}
		} else if (cell.cell_type == 'code') {
			// Perform the default SHIFT+ENTER behavior which is execute
			// current code cell and move to next cell.
			cell.execute();
			Jupyter.notebook.select_next();
	 	} else {
			console.log("No selected cell");
		}
	};

	// Generated by ChatGPT in Jupyter :)
	var formatDate = function() {
		var now = new Date();
		var date = [now.getMonth() + 1, now.getDate(), now.getFullYear()];
		var time = [now.getHours(), now.getMinutes(), now.getSeconds()];
		var suffix = (time[0] < 12) ? "AM" : "PM";
		time[0] = (time[0] < 12) ? time[0] : time[0] - 12;
		time[0] = time[0] || 12;

		// If seconds and minutes are less than 10, add a zero
		for (var i = 1; i < 3; i++) {
			if (time[i] < 10) {
				time[i] = "0" + time[i];
			}
		}

		return date.join("/") + " " + time.join(":") + " " + suffix;
	}

	// Listen for post messages coming from the content script
	// There is a BEGIN message that signfies the start of a response
	// There is a stream of STREAM messages that contain the incremental response
	// There is an END message that signifies the end of the response
	var start_time = new Date();
	const waiting_msg = "##### response: waiting for response from ChatGPT...";

	window.addEventListener("message", function(event) {
		if (event.data.type && (event.data.type == "BEGIN_CONTENT_SCRIPT")) {
			// console.log("Starting!");
			Jupyter.notebook.insert_cell_below();
			Jupyter.notebook.select_next();
			Jupyter.notebook.cells_to_markdown();

			// Start timer
			start_time = new Date();

			// Insert something into the cell to say we're starting now.
			Jupyter.notebook.get_selected_cell().set_text(waiting_msg);
		} else if (event.data.type && (event.data.type == "STREAM_CONTENT_SCRIPT")) {
			// console.log("Streaming: " + event.data.text);
			var response = event.data.text;

			var current_time = new Date();
			var time_difference = current_time - start_time;
			var seconds = Math.floor(time_difference / 1000) % 60;
			var msg = `##### response: ${seconds} seconds elapsed\n\n${response}`;
			
			Jupyter.notebook.get_selected_cell().set_text(msg);
		} else if (event.data.type && (event.data.type == "END_CONTENT_SCRIPT")) {

			// Write the completed message
			let text = Jupyter.notebook.get_selected_cell().get_text()
			var summary = `##### response generated by ChatGPT at ${formatDate(start_time)}\n`;
			text = text.replace(/^\#\#\#\#\# response.*\n/, summary);
			Jupyter.notebook.get_selected_cell().set_text(text);

			// console.log("Final Text: ", text)
			var code_blocks = extractCodeBlocks(text);
			console.log("Extracted code blocks: ", code_blocks);

			// TODO: replace the ``` with ```python so that the code blocks 
			// are highlighted correctly. this will be a hack for now but
			// in the future auto-detection the way highlight.js does it 
			// would be better.
			Jupyter.notebook.get_selected_cell().render();

			// Now inject the parsed code blocks into the notebook
			for (var i = 0; i < code_blocks.length; i++) {
				console.log("Inserting code block: ", code_blocks[i]);
				Jupyter.notebook.insert_cell_below();
				Jupyter.notebook.select_next();
				Jupyter.notebook.get_selected_cell().set_text(code_blocks[i]);
			}
		}
	});

	// TODO: figure out what real values to use for these
	var action = {
		icon: 'fa-comment', // a font-awesome class used on buttons, etc
		help    : 'Send to ChatGPT',
		help_index : 'zz',
		handler : send_to_chatgpt
	};
	var prefix = 'auto';
	var action_name = 'send-to-chatgpt';
	var full_action_name = Jupyter.actions.register(action, action_name, prefix); // returns 'auto:send-to-chatgpt'

	// TODO: I don't really care about whether someone has overridden the shortcut
	// in another extension. Feel free to fix this!
	Jupyter.notebook.keyboard_manager.edit_shortcuts.add_shortcut('shift-enter', full_action_name);

	console.log('Im in yr page, injecting scripts');
})();