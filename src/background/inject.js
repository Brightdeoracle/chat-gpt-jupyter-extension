// This code will be injected by creating an element on the page and 
// injecting a script element onto the page so that I can access the
// existing Jupyter page code.

(function() {
	// Register a custom action that will either execute the 
	// current cell or pop an alert (simulate send to GPT)
	var send_to_chatgpt = function () {
		var cell = Jupyter.notebook.get_selected_cell();
		if (cell.cell_type == 'code') {
			code = cell.get_text();
			if (code.startsWith('%chat')) {
				// Strip off the %chat prefix
				code = code.replace(/^\s*%chat\s*/, "");
				console.log(`Send to ChatGPT ${code}`);

				// Must post a message to the content_script to send to ChatGPT
				// TODO: what does * mean and implications for the timeout?
				window.postMessage({type: "FROM_PAGE", text: code}, "*");
			} else {
				cell.execute();
			}
		} else {
			console.log("No selected cell");
		}
	};

	// Generated by ChatGPT :) in Jupyter 
	function extractCodeBlocks(str) {
		// Use a regular expression to match the code block markers and capture the code between them
		const regex = /^```\n([\s\S]*?)\n```$/gm;

		// Use the String.prototype.match method to find all matches
		const matches = str.match(regex);

		// If there are no matches, return an empty array
		if (!matches) return [];

		// Use the Array.prototype.map method to extract the code from each match
		return matches.map((match) => match.replace(regex, '$1'));
	}

	// Listen for post messages coming from the content script
	// There is a BEGIN message that signfies the start of a response
	// There is a stream of STREAM messages that contain the incremental response
	// There is an END message that signifies the end of the response

	window.addEventListener("message", function(event) {
		if (event.data.type && (event.data.type == "BEGIN_CONTENT_SCRIPT")) {
			// console.log("Starting!");
			Jupyter.notebook.insert_cell_below();
			Jupyter.notebook.select_next();
			Jupyter.notebook.cells_to_markdown();
		} else if (event.data.type && (event.data.type == "STREAM_CONTENT_SCRIPT")) {
			// console.log("Streaming: " + event.data.text);
			Jupyter.notebook.get_selected_cell().set_text(event.data.text);
		} else if (event.data.type && (event.data.type == "END_CONTENT_SCRIPT")) {
			// event.data.text contains the complete response message to parse
			let text = Jupyter.notebook.get_selected_cell().get_text()
			// console.log("Final Text: ", text)
			var code_blocks = extractCodeBlocks(text);
			console.log("Extracted code blocks: ", code_blocks);
			Jupyter.notebook.get_selected_cell().render();

			// Now inject the parsed code blocks into the notebook
			for (var i = 0; i < code_blocks.length; i++) {
				console.log("Inserting code block: ", code_blocks[i]);
				Jupyter.notebook.insert_cell_below();
				Jupyter.notebook.select_next();
				Jupyter.notebook.get_selected_cell().set_text(code_blocks[i]);
			}
		}
	});

	// TODO: figure out what real values to use for these
	var action = {
		icon: 'fa-comment', // a font-awesome class used on buttons, etc
		help    : 'Send to ChatGPT',
		help_index : 'zz',
		handler : send_to_chatgpt
	};
	var prefix = 'auto';
	var action_name = 'send-to-chatgpt';
	var full_action_name = Jupyter.actions.register(action, action_name, prefix); // returns 'auto:send-to-chatgpt'
	Jupyter.notebook.keyboard_manager.edit_shortcuts.add_shortcut('ctrl-enter', full_action_name);

	console.log('Im in yr page, injecting scripts');
})();